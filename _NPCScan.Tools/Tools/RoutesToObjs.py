# -*- coding: utf_8 -*-
"""Converts all recognized Routes paths to Wavefront *.obj model files.

Instructions:
1. Define route data in-game:
   a. Install Routes addon by Xinhuan. <http://wow.curse.com/downloads/wow-addons/details/routes.aspx>
   b. Create a blank path in the desired zone, named with a format
      "Overlay:{NPC ID}:{NPC Name}:{Index Number}[:{Hole Number}]".  Index Number
      separates different paths used by mobs (i.e. "1", "2", etc.), and Hole Number
      flags the path as a hole carved from the parent path.
   c. Outline the region you want without any overlapping sections or duplicate points.
   d. Exit WoW or /reload your UI to save routes to disk.
2. Run this script with relevant file paths to convert Routes' outlines to *.obj files.
"""

import codecs
import math
import os.path
import re

import p2t as poly2tri

import wowdata.dbc as dbc
import wowdata.lua
import wowdata.mpq

__author__ = 'Saiket'
__email__ = 'saiket.wow@gmail.com'
__license__ = 'GPL'

_OUTPUT_LOCALE = 'enUS'  # Locale for output folder and file names

class Overlay(object):
  """Represents a set of routes and route holes making up an NPC's overlay."""
  _COORD_MAX = 10000  # Max coord value in Routes' save format

  def __init__(self, worldMapName, npcID, npcName):
    self.worldMapName, self.npcID, self.npcName = worldMapName, npcID, npcName
    self.polylines, self.holes = {}, {}

  def _routeToPolyline(self, route):
    """Converts a route from Routes' saved variables to a list of points."""
    polyline = []
    for index, coord in route.items():
      coord = float(coord)
      x = math.floor(coord / self._COORD_MAX) / self._COORD_MAX
      y = 1 - (coord % self._COORD_MAX) / self._COORD_MAX  # Y-axis is flipped in map coords
      polyline.append(poly2tri.Point(x, y))
    return polyline

  def _addVertex(self, point):
    """Adds a vertex to the vertex list and returns its index."""
    vertex = (point.x, point.y, 0)
    if vertex not in self.vertexIndices:
      self.vertexIndices[vertex] = len(self.vertices)
      self.vertices.append(vertex)
    return self.vertexIndices[vertex] + 1  # *.obj vertexes are 1-indexed

  def _triangulate(self):
    """Compiles all routes into sets of triangles."""
    self.vertices, self.vertexIndices, self.trisByPolyline = [], {}, {}
    for index, polyline in sorted(self.polylines.iteritems()):
      cdt = poly2tri.CDT(polyline)  # Constrained Delaunay Triangulation
      if index in self.holes:
        for holeIndex, hole in sorted(self.holes[index].iteritems()):
          cdt.add_hole(hole)
      # Separate each polyline's triangles for grouping in the *.obj
      self.trisByPolyline[index] = []
      for triangle in cdt.triangulate():
        self.trisByPolyline[index].append(
          (self._addVertex(triangle.a), self._addVertex(triangle.b), self._addVertex(triangle.c)))

  def addRoute(self, route, index, holeIndex=None):
    """Adds a route to this overlay, optionally as a hole to carve from an existing route."""
    polyline = self._routeToPolyline(route)
    if holeIndex is None:
      self.polylines[index] = polyline
    else:
      if index not in self.holes:
        self.holes[index] = {}
      self.holes[index][holeIndex] = polyline

  def writeObj(self, outputPath, filename):
    """Writes an *.obj model file representing this overlay's geometry."""
    self._triangulate()
    with codecs.open(os.path.join(outputPath, filename), 'w+', encoding='utf_8') as output:
      output.write('# AUTOMATICALLY GENERATED BY <%s>!\n' % __file__)
      output.write('o WorldMap %s, Npc %d: %s\n' % (  # Object name
        self.worldMapName, self.npcID, self.npcName))

      for vertex in self.vertices:
        output.write('\nv %.06f %.06f %.06f' % vertex)  # Vertex

      for index, triangles in sorted(self.trisByPolyline.iteritems()):
        output.write('\n\ng Route %d' % index)  # Group name
        for triangle in triangles:
          output.write('\nf %d %d %d' % triangle)  # Face


def routesToObjs(dataPath, routesFilename, outputPath):
  """Reads paths from Routes' saved variables and writes them to *.obj model files."""
  dataPath = os.path.normcase(dataPath)
  routesFilename = os.path.normcase(routesFilename)
  outputPath = os.path.normcase(outputPath)
  print 'Unpacking <%s> to <%s>...' % (routesFilename, outputPath)

  with wowdata.mpq.openLocaleMPQ(dataPath, _OUTPUT_LOCALE) as archive:
    with \
      dbc.DBC(archive.open('DBFilesClient/WorldMapArea.dbc'),
        'id', None, 'areaTableID', 'filename', flags=11) as worldMapAreas, \
      dbc.DBC(archive.open('DBFilesClient/AreaTable.dbc'),
        'id', name=11) as areaTable \
    :
      worldMapAreas.rows = {worldMap.int('id'): worldMap for worldMap in worldMapAreas}
      areaTable.rows = {area.int('id'): area for area in areaTable}

      # Create a lookup of world map filenames to world map IDs
      FLAG_PHASE = 0x2
      worldMapIDs = {}
      for id, worldMap in worldMapAreas.rows.iteritems():
        if (worldMap.int('areaTableID')  # Not a continent
          and not worldMap.int('flags') & FLAG_PHASE  # Not a phased map
        ):
          worldMapIDs[worldMap.str('filename')] = id

      # Write NPC *.obj models into their respective world map folders
      for worldMap, routes in sorted(
        wowdata.lua.loadSavedVariables(routesFilename)['RoutesDB']['global']['routes'].items(),
        key=lambda item: worldMapIDs[item[0].decode('utf_8')]
      ):
        worldMapID = worldMapIDs[worldMap.decode('utf_8')]
        areaTableID = worldMapAreas.rows[worldMapID].int('areaTableID')
        worldMapName = areaTable.rows[areaTableID].str('name')
        # Group routes on this map by the NPCs they represent
        overlays = {}
        for name in routes.keys():
          match = re.match(r'^Overlay:(?P<npcID>\d+):(?P<name>[^:]+):(?P<index>\d+)(?::(?P<hole>\d+))?$',
            name.decode('utf_8'))
          if match:  # Path is an overlay outline
            npcID = int(match.group('npcID'))
            if npcID not in overlays:
              overlays[npcID] = Overlay(worldMapName, npcID, match.group('name'))
            index, holeIndex = int(match.group('index')), match.group('hole')
            if holeIndex is not None:
              holeIndex = int(holeIndex)
            overlays[npcID].addRoute(routes[name].route, index, holeIndex)

        if overlays:  # At least one NPC on this world map
          objFolder = 'WorldMap%d - %s' % (worldMapID, worldMapName)
          print '\t%r:' % objFolder
          objFolder = os.path.join(outputPath, objFolder)
          if not os.path.exists(objFolder):
            os.mkdir(objFolder)

          # Write one *.obj for each NPC's routes
          for npcID, overlay in sorted(overlays.iteritems()):
            objFilename = 'Npc%d - %s.obj' % (npcID, overlay.npcName)
            print '\t\t%r' % objFilename
            overlay.writeObj(objFolder, objFilename)


if __name__ == '__main__':
  import argparse
  parser = argparse.ArgumentParser(
    description='Convert Routes\' saved variables file to *.obj models.',
    epilog=''.join((__doc__ or '').splitlines(True)[2:]),  # Duplicate file docstring's instructions
    formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('dataPath', type=unicode,
    help='The path to World of Warcraft\'s Data folder.')
  parser.add_argument('routesFilename', type=unicode,
    help='The path to Routes\' account-wide saved variables file in your WTF folder.')
  parser.add_argument('outputPath', type=unicode,
    help='Path to store generated *.obj models in.')
  routesToObjs(**vars(parser.parse_args()))