# -*- coding: utf_8 -*-
"""Builds a source file of NPC data for _NPCScan.Tools."""

import collections
import os.path
import re
import struct
import time

import PyV8

import wowdata.dbc as dbc
import wowdata.lua
import wowdata.mpq
import wowdata.wowhead

__author__ = 'Saiket'
__email__ = 'saiket.wow@gmail.com'
__license__ = 'GPL'

_BYTES_PER_COORD = 2
_COORD_MAX = 2 ** (8 * _BYTES_PER_COORD) - 1
_REQUEST_INTERVAL = 60  # Seconds between NPC requests

class _JSBreak(Exception):
  """Sentinel exception thrown to stop JS execution once data is defined."""
  def __init__(self):  # Note: Older PyV8 builds always throw JSError, so identify by name instead
    super(_JSBreak, self).__init__(_JSBreak.__name__)


class _Globals(PyV8.JSClass):
  """JS global scope with simulated Wowhead APIs to intercept NPC data."""
  def Mapper(self, data):
    raise _JSBreak()


def _getNPCData(npcID, locale):
  """Returns this NPC's display ID and map data by areaID and dungeon level."""
  page = wowdata.wowhead.getPage(locale, 'npc=%d' % npcID)
  displayID, areaData = None, None

  anchor = page.find('a', id='dsgndslgn464d')  # "View in 3D" button
  if anchor is not None and anchor.has_attr('onclick'):
    match = re.search(r'\bdisplayId: (\d+)\b', anchor['onclick'])
    if match is None:
      raise wowdata.wowhead.InvalidResultError(
        'DisplayID not found in onclick handler %r.' % anchor['onclick'])
    displayID = int(match.group(1))

  div = page.find('div', id='k6b43j6b')  # Map view
  if div is not None:
    try:
      script = div.find_next_sibling('script', type='text/javascript').get_text()
    except AttributeError:
      raise wowdata.wowhead.InvalidResultError('Map data script not found.')
    with PyV8.JSContext(_Globals()) as context:
      try:
        context.eval(script.encode('utf_8'))
      except _JSBreak:
        pass
      except PyV8.JSError as e:  # Note: Older PyV8 builds swallow custom exceptions
        if e.message != _JSBreak.__name__:
          raise
      try:
        mapperData = context.locals.g_mapperData
      except AttributeError:
        raise wowdata.wowhead.InvalidResultError('Map data didn\'t define g_mapperData.')
      getValue = context.eval('''
        /// Note: Workaround for PyV8.JSObject only allowing string keys
        (function ( Object, Key ) {
          return Object[ Key ];
        })
        ''')
      areaData = {}
      for areaID in mapperData.keys():
        levels = getValue(mapperData, areaID)
        areaData[areaID] = {}
        for level in levels.keys():
          vertices = []
          for vertex in getValue(levels, level)['coords']:
            vertices.append((float(vertex[0]) / 100, float(vertex[1]) / 100))
          areaData[areaID][level] = vertices
  return displayID, areaData


def _nestedDefaultDict():
  """Returns a `defaultdict` which automatically creates sub-dictionaries."""
  return collections.defaultdict(_nestedDefaultDict)


def updateNPCData(dataPath, outputFilename, locale):
  """Compiles data about rare mobs from Wowhead to a Lua source file."""
  dataPath = os.path.normcase(dataPath)
  outputFilename = os.path.normcase(outputFilename)
  print 'Writing all rare NPC data from %s Wowhead to <%s>...' % (locale, outputFilename)
  npcs = wowdata.wowhead.getNPCsAllLevels(locale, cl='2:4')  # Rare and rare elite

  # Create a lookup for zone AreaTable IDs used by WowHead to WorldMapArea IDs
  with wowdata.mpq.openLocaleMPQ(dataPath, locale) as archive:
    with dbc.DBC(archive.open('DBFilesClient/WorldMapArea.dbc'),
      'id', None, 'areaTableID', flags=11) as worldMapAreas \
    :
      FLAG_PHASE = 0x2
      worldMapAreaIDs = {}
      for worldMap in worldMapAreas:
        areaTableID = worldMap.int('areaTableID')
        if (areaTableID  # Not a continent
          and not worldMap.int('flags') & FLAG_PHASE  # Not a phased map
        ):
          worldMapAreaIDs[areaTableID] = worldMap.int('id')

  # Query each NPC for details
  displayIDs, worldMapData = {}, _nestedDefaultDict()
  for npcID, npcData in sorted(npcs.iteritems()):
    print '\tNpc%d - %r' % (npcID, npcData['name'].decode('utf_8'))
    try:
      displayID, areaData = _getNPCData(npcID, locale)
    except Exception as e:
      print '\t\tError reading NPC Data: %r' % e
    else:
      if displayID is not None:
        displayIDs[npcID] = displayID
      if areaData is not None:
        # Merge into main world map data
        for areaID, levels in areaData.iteritems():
          if areaID in worldMapAreaIDs:  # Has a world map
            for level, vertices in levels.iteritems():
              worldMapData[worldMapAreaIDs[areaID]][level][npcID] = vertices
    time.sleep(_REQUEST_INTERVAL)

  with open(outputFilename, 'w+b') as output:
    output.write('-- AUTOMATICALLY GENERATED BY <%s>!\n' % __file__)
    output.write('select( 2, ... ).NPCData = {\n')

    output.write('\tNames = {\n')
    for npcID, npcData in sorted(npcs.iteritems()):
      name = wowdata.lua.escapeData(npcData['name'])
      output.write('\t\t[ %d ] = %s;\n' % (npcID, name))
    output.write('\t};\n')

    output.write('\tDisplayIDs = {\n')
    for npcID, displayID in sorted(displayIDs.iteritems()):
      output.write('\t\t[ %d ] = %d;\n' % (npcID, displayID))
    output.write('\t};\n')

    # Write point data per world map per floor.
    output.write('\tMapData = {\n')
    for worldMapID, worldMap in sorted(worldMapData.iteritems()):
      if worldMap:  # At least one level in world map
        output.write('\t\t[ %d ] = {\n' % worldMapID)
        for level, npcData in sorted(worldMap.iteritems()):
          if npcData:  # At least one NPC on this level
            output.write('\t\t\t[ %d ] = {\n' % level)
            for npcID, vertices in sorted(npcData.iteritems()):
              if vertices:  # At least one known coordinate
                bytes = []
                for vertex in sorted(vertices):
                  for coord in vertex:
                    bytes.append(struct.pack('>H', round(coord * _COORD_MAX)))  # Big-endian unsigned short
                data = wowdata.lua.escapeData(''.join(bytes))
                output.write('\t\t\t\t[ %d ] = %s;\n' % (npcID, data))
            output.write('\t\t\t};\n')
        output.write('\t\t};\n')
    output.write('\t};\n')
    output.write('};')


if __name__ == '__main__':
  import argparse
  parser = argparse.ArgumentParser(
    description='Compiles NPC data for _NPCScan.Tools.')
  parser.add_argument('--locale', '-l', type=unicode, required=True,
    help='Locale code to retrieve data for.')
  parser.add_argument('dataPath', type=unicode,
    help='The path to World of Warcraft\'s Data folder.')
  parser.add_argument('outputFilename', type=unicode,
    help='Output path for the resulting Lua source file.')
  updateNPCData(**vars(parser.parse_args()))