# -*- coding: utf_8 -*-
"""Converts all recognized Routes paths to Wavefront *.obj model files.

Instructions:
1. Define route data in-game:
   a. Install Routes addon by Xinhuan. <http://wow.curse.com/downloads/wow-addons/details/routes.aspx>
   b. Create a blank path in the desired zone, named with a format
      "Overlay:{NPC ID}:{NPC Name}:{Index Number}[:{Hole Number}]".  Index Number
      separates different paths used by mobs (i.e. "1", "2", etc.), and Hole Number
      flags the path as a hole carved from the parent path.
   c. Outline the region you want without any overlapping sections or duplicate points.
   d. Exit WoW or /reload your UI to save routes to disk.
2. Run this script with relevant file paths to convert Routes' outlines to *.obj files.
"""

import codecs
import os.path
import re

import p2t as poly2tri

import wowdata.dbc as dbc
import wowdata.lua
import wowdata.mpq

__author__ = 'Saiket'
__email__ = 'saiket.wow@gmail.com'
__license__ = 'GPL'

_OUTPUT_LOCALE = 'enUS'  # Locale for output folder and file names

class Overlay(object):
  """Represents a set of routes and route holes making up an NPC's overlay."""
  _COORD_MAX = 10000  # Max coord value in Routes' save format

  def __init__(self, worldmap_name, npc_id, npc_name):
    self.worldmap_name, self.npc_id, self.npc_name = worldmap_name, npc_id, npc_name
    self.polylines, self.holes = {}, {}

  def _route_to_polyline(self, route):
    """Converts a route from Routes' saved variables to a list of points."""
    polyline = []
    for index, coord in route.items():
      coord = float(coord)
      x = coord // self._COORD_MAX / self._COORD_MAX
      y = 1 - (coord % self._COORD_MAX) / self._COORD_MAX  # Y-axis is flipped in map coords
      polyline.append(poly2tri.Point(x, y))
    return polyline

  def _add_vertex(self, point):
    """Adds a vertex to the vertex list and returns its index."""
    vertex = (point.x, point.y, 0)
    if vertex not in self.vertex_indices:
      self.vertex_indices[vertex] = len(self.vertices)
      self.vertices.append(vertex)
    return self.vertex_indices[vertex] + 1  # *.obj vertexes are 1-indexed

  def _triangulate(self):
    """Compiles all routes into sets of triangles."""
    self.vertices, self.vertex_indices, self.polyline_tris = [], {}, {}
    for index, polyline in sorted(self.polylines.iteritems()):
      cdt = poly2tri.CDT(polyline)  # Constrained Delaunay Triangulation
      if index in self.holes:
        for hole_index, hole in sorted(self.holes[index].iteritems()):
          cdt.add_hole(hole)
      # Separate each polyline's triangles for grouping in the *.obj
      self.polyline_tris[index] = []
      for triangle in cdt.triangulate():
        self.polyline_tris[index].append(
          (self._add_vertex(triangle.a), self._add_vertex(triangle.b), self._add_vertex(triangle.c)))

  def add_route(self, route, index, hole_index=None):
    """Adds a route to this overlay, optionally as a hole to carve from an existing route."""
    polyline = self._route_to_polyline(route)
    if hole_index is None:
      self.polylines[index] = polyline
    else:
      if index not in self.holes:
        self.holes[index] = {}
      self.holes[index][hole_index] = polyline

  def write_obj(self, output_path, filename):
    """Writes an *.obj model file representing this overlay's geometry."""
    self._triangulate()
    with codecs.open(os.path.join(output_path, filename), 'w+', encoding='utf_8') as output:
      output.write('# AUTOMATICALLY GENERATED BY <%s>!\n' % __file__)
      output.write('o WorldMap %s, Npc %d: %s\n' % (  # Object name
        self.worldmap_name, self.npc_id, self.npc_name))

      for vertex in self.vertices:
        output.write('\nv %.06f %.06f %.06f' % vertex)  # Vertex

      for index, triangles in sorted(self.polyline_tris.iteritems()):
        output.write('\n\ng Route %d' % index)  # Group name
        for triangle in triangles:
          output.write('\nf %d %d %d' % triangle)  # Face


def write(output_path, data_path, routes_filename):
  """Reads paths from Routes' saved variables and writes them to *.obj model files."""
  output_path = os.path.normcase(output_path)
  data_path = os.path.normcase(data_path)
  routes_filename = os.path.normcase(routes_filename)
  print 'Unpacking <%s> to <%s>...' % (routes_filename, output_path)

  with wowdata.mpq.open_locale_mpq(data_path, _OUTPUT_LOCALE) as archive:
    with \
      dbc.DBC(archive.open('DBFilesClient/WorldMapArea.dbc'),
        'id', None, 'area_id', 'filename', flags=11) as worldmaps, \
      dbc.DBC(archive.open('DBFilesClient/AreaTable.dbc'),
        'id', name=11) as areas \
    :
      worldmaps.rows = {worldmap.int('id'): worldmap for worldmap in worldmaps}
      areas.rows = {area.int('id'): area for area in areas}

      # Create a lookup of world map filenames to world map IDs
      FLAG_PHASE = 0x2
      worldmap_ids = {}
      for id, worldmap in worldmaps.rows.iteritems():
        if (worldmap.int('area_id')  # Not a continent
          and not worldmap.int('flags') & FLAG_PHASE  # Not a phased map
        ):
          worldmap_ids[worldmap.str('filename')] = id

      # Write NPC *.obj models into their respective world map folders
      for worldmap, routes in sorted(
        wowdata.lua.load_saved_variables(routes_filename)['RoutesDB']['global']['routes'].items(),
        key=lambda item: worldmap_ids[item[0].decode('utf_8')]
      ):
        worldmap_id = worldmap_ids[worldmap.decode('utf_8')]
        area_id = worldmaps.rows[worldmap_id].int('area_id')
        worldmap_name = areas.rows[area_id].str('name')
        # Group routes on this map by the NPCs they represent
        overlays = {}
        for name in routes.keys():
          match = re.match(r'^Overlay:(?P<npc_id>\d+):(?P<name>[^:]+):(?P<index>\d+)(?::(?P<hole>\d+))?$',
            name.decode('utf_8'))
          if match:  # Path is an overlay outline
            npc_id = int(match.group('npc_id'))
            if npc_id not in overlays:
              overlays[npc_id] = Overlay(worldmap_name, npc_id, match.group('name'))
            index, hole_index = int(match.group('index')), match.group('hole')
            if hole_index is not None:
              hole_index = int(hole_index)
            overlays[npc_id].add_route(routes[name].route, index, hole_index)

        if overlays:  # At least one NPC on this world map
          obj_folder = 'WorldMap%d - %s' % (worldmap_id, worldmap_name)
          print '\t%r:' % obj_folder
          obj_folder = os.path.join(output_path, obj_folder)
          if not os.path.exists(obj_folder):
            os.mkdir(obj_folder)

          # Write one *.obj for each NPC's routes
          for npc_id, overlay in sorted(overlays.iteritems()):
            obj_filename = 'Npc%d - %s.obj' % (npc_id, overlay.npc_name)
            print '\t\t%r' % obj_filename
            overlay.write_obj(obj_folder, obj_filename)


if __name__ == '__main__':
  import argparse
  parser = argparse.ArgumentParser(
    description='Convert Routes\' saved variables file to *.obj models.',
    epilog=''.join((__doc__ or '').splitlines(True)[2:]),  # Duplicate file docstring's instructions
    formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('data_path', type=unicode,
    help='The path to World of Warcraft\'s Data folder.')
  parser.add_argument('routes_filename', type=unicode,
    help='The path to Routes\' account-wide saved variables file in your WTF folder.')
  parser.add_argument('output_path', type=unicode,
    help='Path to store generated *.obj models in.')
  write(**vars(parser.parse_args()))