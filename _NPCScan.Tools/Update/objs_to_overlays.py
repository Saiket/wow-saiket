# -*- coding: utf_8 -*-
"""Joins Wavefront *.obj model files into a binary data file for _NPCScan.Overlay.

Instructions:
1. Run <routes_to_objs.py> to build a folder of world map sub-folders with NPC *.obj
   files from outlines in your Routes saved variables.
2. Run this script with relevant file paths to pack resulting *.obj files into
   a Lua source file for _NPCScan.Overlay.
"""

import codecs
import os
import re
import struct

import wowdata.lua

__author__ = 'Saiket'
__email__ = 'saiket.wow@gmail.com'
__license__ = 'GPL'

class Obj(object):
  """Represents an *.obj model file to be packed for _NPCScan.Overlay."""
  _BYTES_PER_COORD = 2
  _COORD_MAX = 2 ** (8 * _BYTES_PER_COORD) - 1

  def __init__(self, filename):
    """Parses the *.obj file for vertex and face information."""
    self.vertices, self.triangles = [], []
    with codecs.open(filename, encoding='utf_8') as input:
      for line in input:
        words = line.split()
        if words:
          operator = words.pop(0).lower()
          if operator == 'v':  # Vertex
            if len(words) == 3:
              self.vertices.append(tuple(map(float, words)))
          elif operator == 'f':  # Face
            if len(words) == 3:
              # *.obj vertices are 1-indexed
              self.triangles.append(tuple(int(word) - 1 for word in words))

  def get_path_data(self):
    """Returns a binary representation of this overlay's geometry."""
    bytes = []
    for triangle in self.triangles:
      for index in triangle:
        vertex = list(self.vertices[index][:2])  # Omit Z-axis
        vertex[1] = 1 - vertex[1]  # Y-axis is flipped on world map
        for coord in vertex:
          bytes.append(struct.pack('>H', round(coord * self._COORD_MAX)))  # Big-endian unsigned short
    return ''.join(bytes)


def write(output_filename, input_path):
  """Reads *.obj files from an input folder and packs them into a Lua source file."""
  output_filename = os.path.normcase(output_filename)
  input_path = os.path.normcase(unicode(input_path))
  print 'Packing *.obj files from <{:s}> to <{:s}>...'.format(input_path, output_filename)

  with open(output_filename, 'w+b') as output:
    output.write('-- AUTOMATICALLY GENERATED BY <' + __file__.encode('utf_8') + '>!\n')
    output.write('select( 2, ... ).PathData = {\n')

    worldmap_match = re.compile(r'^WorldMap(?P<id>\d+) - (?P<name>.+)$', flags=re.IGNORECASE).match
    npc_match = re.compile(r'^Npc(?P<id>\d+) - (?P<name>.+)\.obj$', flags=re.IGNORECASE).match
    for worldmap_id, worldmap_name, worldmap_folder in sorted(
      (int(match.group('id')), match.group('name'), match.string) for match
        in map(worldmap_match, os.listdir(input_path))
        if match and os.path.isdir(os.path.join(input_path, match.string))
    ):
      matches = [match for match
        in map(npc_match, os.listdir(os.path.join(input_path, worldmap_folder)))
        if match and os.path.isfile(os.path.join(input_path, worldmap_folder, match.string))]
      if matches:  # At least one *.obj file
        output.write('\t[ ' + str(worldmap_id) + ' ] = { -- '
          + worldmap_name.encode('utf_8') + '\n')
        print '\t{!r}:'.format(worldmap_folder)
        for npc_id, npc_name, obj_filename in sorted(
          (int(match.group('id')), match.group('name'), match.string) for match in matches
        ):
          print '\t\t{!r}'.format(obj_filename)
          output.write('\t\t-- ' + npc_name.encode('utf_8') + '\n')
          obj = Obj(os.path.join(input_path, worldmap_folder, obj_filename))
          output.write('\t\t[ ' + str(npc_id) + ' ] = '
            + wowdata.lua.escape_data(obj.get_path_data()) + ';\n')
        output.write('\t};\n')
    output.write('};')


if __name__ == '__main__':
  import argparse
  parser = argparse.ArgumentParser(
    description='Convert *.obj models to a Lua source file for _NPCScan.Overlay.',
    epilog=''.join((__doc__ or '').splitlines(True)[2:]),  # Duplicate file docstring's instructions
    formatter_class=argparse.RawDescriptionHelpFormatter)
  parser.add_argument('input_path', type=unicode,
    help='Path containing *.obj models generated by RoutesToObjs.py.')
  parser.add_argument('output_filename', type=unicode,
    help='Output path for the resulting Lua source file.')
  write(**vars(parser.parse_args()))